# EXT4

## 文件系统ext4的实现原理是什么？
ext4文件系统是Linux下的一种高度可扩展的日志式文件系统，它是ext3文件系统的后继版本。ext4的设计和实现原理主要涉及以下几个关键方面：

- 日志功能（Journaling）：
• ext4继承了ext3的日志机制，通过维护一个日志区域记录元数据更改，增强了文件系统的可靠性。在系统崩溃时，可以通过重播日志快速恢复文件系统的一致性。

- inode改进：
• ext4大幅度增加了inode所能支持的大小，并且允许动态分配inode。每个inode可以存储更多的直接指针，从而支持更大的文件以及更高效的存储小文件。

- 块组描述符（Block Group Descriptor）：
• ext4文件系统将磁盘空间划分为多个块组，每个块组包含一组系统元数据如inode表、块位图等。增强的块组描述符结构允许更大程度上的灵活性和空间利用率。

- 多块预读与写回（Multi-block Allocation and Delayed Block Allocation）：
• 当应用程序连续写入大量数据时，ext4能够一次性预分配多个连续的数据块，提高性能；同时采用了延迟块分配策略，在修改文件内容时，仅记录分配操作而实际分配物理块可以在稍后进行。

- 目录项与extent树：
• ext4使用extent树来跟踪文件所占用的磁盘块范围，取代了ext3中较为低效的链表方式。这使得对大文件的操作效率更高，寻址速度更快。

- 大文件系统与大文件支持：
• ext4支持高达1 EB（Exabyte）的文件系统容量，单个文件最大可达16TB，极大地提高了容量上限。

- 在线碎片整理与更好的空间管理：
• ext4提供了在线碎片整理功能，并通过更好的空间分配策略减少碎片产生，优化磁盘空间利用。

总的来说，ext4通过对ext3进行深度改进，实现了更高的文件系统容量、更强的可靠性、更好的性能以及更加灵活的空间管理策略。

## 它的实现代码在哪里？
ext4文件系统的实现代码位于Linux内核源码中。具体而言，在Linux内核的filesystems目录下，ext4文件系统的源码通常位于 fs/ext4/目录及其子目录中。例如：
- ext4.h• ：包含头文件，定义了ext4结构、常量和函数原型。

- ext4_block.c• 、ext4_inode.c• 等：分别实现了块管理、inode管理等相关功能。

- ext4_jbd2.c• : 实现与日志（journaling）相关的功能。
- ext4_file.c• 、ext4_dir.c• 等：处理文件、目录的操作。

如果您想要查阅或研究ext4的实现细节，可以从最新版本的Linux内核源代码开始。开发者可以下载内核源码并查看相关部分以了解其实现原理和技术细节。这些源码是开放源码的，可以通过GitHub上的Linux内核仓库或者其他托管平台获取。

## 当我修改了一个文件中的某个字符，它直接修改这个文件不好吗？为什么要把修改先写到日志中呢？
在文件系统中，尤其是日志式文件系统（如ext4）中，并不是直接修改文件的实际数据块，而是首先将修改操作记录在日志中，这是因为：
- 数据一致性与完整性：
• 当系统在更新文件或元数据的过程中突然崩溃时，如果没有先写入日志，那么这些未完成的更改可能导致文件系统的不一致状态。通过先将更改写入日志，系统在重启后可以通过重播日志来确保所有的更改都按正确的顺序完整地执行，从而恢复数据的一致性。

- 快速恢复：
• 如果直接修改文件数据和元数据，当出现异常时，需要进行耗时的文件系统检查（例如fsck）以确定数据块的状态。而在日志式文件系统中，只需要回滚或重放日志就能迅速恢复到一个已知的良好状态。

- 性能优化：
• 日志还可以帮助提高并发写入的性能。由于磁盘的物理特性，顺序写入（如日志区域）通常比随机写入（如直接修改分散在磁盘各处的数据块）更快。因此，先缓冲变更于日志区域能减少实际数据块上的磁盘IO冲突。

综上所述，在日志式文件系统中，采用“先写日志”的方式是为了提供更强的数据保障和更稳定的系统性能。在完成一系列相关更改并将它们安全地写入磁盘之后，对应的日志记录才会被清理，以便用于下一轮的操作记录。

## 还有哪些系统是通过先写日志，再修改数据的？
不仅仅是文件系统，数据库管理系统（DBMS）普遍采用了类似的日志先行（Write-Ahead Logging, WAL）机制来保证事务的一致性和持久性。以下是一些采用WAL技术的数据库系统：

- SQL Server：
• Microsoft SQL Server 采用了事务日志来确保ACID属性，即在修改任何数据页之前，它会先将更改记录写入事务日志中。

- MySQL / MariaDB：
• MySQL 的 InnoDB 存储引擎使用了WAL机制，对于数据修改操作，会首先将改动信息记录到重做日志（redo log）中，然后更新内存缓冲池中的数据，最后在适当的时间将缓存的数据刷新到磁盘。

- PostgreSQL：
• PostgreSQL 也实现了WAL机制，所有对数据库的改变在被实际应用到磁盘上的数据文件之前，都会先被记录在预写式日志（write-ahead log）里面。

- Oracle Database：
• Oracle 数据库同样依赖于redo日志实现事务处理，所有的数据修改都是先写日志后写数据块。

- SQLite：
• SQLite 尽管主要用于嵌入式环境，但其内部也同样设计了WAL模式以提高性能和保证事务完整性。

通过WAL机制，这些数据库系统能够在发生意外故障时快速恢复，并且能够提高写入操作的并发性能，因为它允许多个事务同时在其各自的日志部分进行写入而不需要立即同步到磁盘上的数据文件。


## Very it
```
$ echo "abc" > empty

$ mkdir empty-dir

$ du -sh empty
4.0K	empty

$ du -sh empty-dir/
4.0K	empty-dir/
```

