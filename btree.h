#include <iostream>
#include <vector>
#include <queue>
using namespace std;

/*

如果服务端接入了很多客户端，如何做会话的亲和性？
IP地址和端口号：最简单的方法是为每个客户端分配唯一的IP地址和端口号组合。这样，特定客户端的请求将总是被路由到同一个服务器端进程，确保会话亲和性。
Cookie：在Web应用程序中，可以使用会话Cookie来维护会话亲和性。服务器在客户端的第一次请求中发送一个唯一的会话标识符（通常是Cookie），客户端在随后的请求中将这个标识符包含在请求中。服务器使用这个标识符将请求路由到正确的会话。
URL重写：在某些情况下，会话标识符可以通过URL参数进行传递。服务器生成带有会话标识符的URL，并将其返回给客户端。客户端在随后的请求中使用这个URL，确保请求被路由到正确的会话。
SSL会话标识符：在使用SSL/TLS进行安全通信的情况下，SSL会话标识符可以用于维护会话亲和性。
分布式会话存储：如果应用程序在多个服务器上运行，可以使用分布式缓存或数据库来存储会话数据，确保在任何服务器上都可以访问相同的会话信息。
负载均衡器配置：负载均衡器可以配置为使用一些均衡算法，如IP哈希或源IP地址绑定，以确保特定客户端的请求被路由到相同的服务器。


用户将文件上传到服务端的文件系统，服务器如何做流量控制？
带宽限制：服务器可以限制每个客户端或连接的带宽。这可以通过配置服务器或使用专门的带宽管理工具来实现。服务器可以设置每个连接的最大传输速率，以确保资源分配合理。
队列管理：服务器可以为文件上传请求维护一个队列，以限制同时处理的请求数。这可以防止太多的客户端同时上传文件导致资源不足。
请求配额：为了确保公平性，服务器可以为每个客户端设置请求配额。这意味着每个客户端在一段时间内只能上传一定数量的文件或数据。
等待时间：如果服务器资源有限，可以要求客户端在上传文件之前等待一段时间。这种等待时间可以根据服务器负载情况进行调整。
资源监控：服务器可以监控系统资源的使用情况，如CPU、内存和磁盘空间。如果资源接近枯竭，服务器可以暂停或拒绝新的上传请求，直到资源恢复正常。
压缩和分片：服务器可以要求客户端在上传文件之前对文件进行压缩，以减少传输的数据量。另外，可以要求客户端将大文件分成小块进行上传，以减轻服务器的负担。
错误处理：如果上传中断或失败，服务器应该有适当的错误处理机制，以便及时释放资源，防止资源泄漏。
记录和监控：服务器应该记录上传请求的信息，以便进行后续分析和监控，以便及时检测并解决潜在的流量控制问题。


如何分别对普通用户和VIP用户做流量管控？
带宽限制：普通用户可以被限制在较低的带宽上，以确保他们不会占用过多的网络资源，而VIP用户可以获得更高的带宽。这可以通过流量调度器或带宽管理设备来实现。
配额控制：可以为VIP用户分配更多的资源配额，如下载量、上传量或请求次数。这样，VIP用户可以享受更多的服务资源。
并发连接限制：对于某些服务，可以限制普通用户的并发连接数，以防止滥用。VIP用户可以享有更高的并发连接限制。
优先级队列：在高负载情况下，可以为VIP用户的请求设置更高的优先级，以确保他们的请求在普通用户之前获得服务。
高级服务：VIP用户可以获得更多的高级服务功能，如无广告浏览、高清视频流或更快的下载速度。
访问控制列表（ACL）：使用ACL来限制普通用户对某些内容的访问，或允许VIP用户访问特定的资源。
计费策略：VIP用户通常需要支付额外的费用来享受更多的服务。这可以通过不同的计费策略来实现，如包月、包年或按使用量计费。
用户身份验证：通过用户身份验证来识别VIP用户，以确保只有已认证的用户才能享受VIP服务。


C++中如何实现单例模式？
懒汉模式
懒汉模式是在首次请求单例实例时才进行初始化，以延迟对象的创建。这种方式在需要时才创建单例，节省了资源，但需要考虑线程安全。

饿汉模式
饿汉模式是在类加载时就创建单例实例，无论是否需要。这种方式在程序启动时就创建单例，无需考虑线程安全问题。
饿汉模式的优点是不需要考虑线程安全问题，但缺点是在程序启动时创建单例可能占用资源，甚至在不需要单例时浪费了资源。



如果一堆数据中，很多数据都局部有序，选择哪个排序方式更好？
通常情况下，使用归并排序（Merge Sort）可能是更好的选择。
归并排序的一个主要优点是它在合并局部有序的数据时表现良好，因为归并排序的核心思想是合并两个已排序的子数组，而这些局部有序的子数组正是归并排序的强项。
与归并排序不同，快速排序（Quick Sort）在处理局部有序的数据时性能可能不如归并排序。快速排序的性能高度依赖于划分的质量，如果数据已经大致有序，那么快速排序可能需要多次划分才能达到平均情况下的性能。


二叉树层序遍历具体实现过程？
描述：给你二叉树的根节点 root ，返回其节点值的 层序遍历 。（即逐层地，从左到右访问所有节点）。
思路：
创建一个队列 queue 用于存储将要访问的节点。
将根节点 root 入队。
进入循环，直到队列为空。
在每次循环中，先计算队列的当前大小 levelSize，这表示当前层的节点数。
创建一个空列表 currentLevel，用于存储当前层的节点值。
从队列中弹出 levelSize 个节点，并将它们的值加入 currentLevel。
将这些节点的非空子节点入队，继续下一层的遍历。
将 currentLevel 加入结果列表 result。
返回 result，其中包含了按层次顺序遍历的节点值。

*/
// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) {
        return result; // 如果根节点为空，返回空的结果
    }

    queue<TreeNode*> queue;
    queue.push(root);

    while (!queue.empty()) {
        int levelSize = queue.size();
        vector<int> currentLevel;

        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = queue.front();
            queue.pop();
            currentLevel.push_back(node->val);

            if (node->left) {
                queue.push(node->left);
            }
            if (node->right) {
                queue.push(node->right);
            }
        }

        result.push_back(currentLevel);
    }

    return result;
}

int main() {
    // 创建一个二叉树示例
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(9);
    root->right = new TreeNode(20);
    root->right->left = new TreeNode(15);
    root->right->right = new TreeNode(7);

    vector<vector<int>> result = levelOrder(root);

    // 打印层序遍历结果
    for (const vector<int>& level : result) {
        for (int val : level) {
            cout << val << " ";
        }
        cout << endl;
    }

    return 0;
}
