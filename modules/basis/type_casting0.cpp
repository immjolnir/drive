#include <gtest/gtest.h>

#include <gmock/gmock.h>
#include <cstddef>
#include <cstring>

/**
 * 4 types casting operations
 * 
 * const_cast
 * dynamic_cast
 * static_cast
 * reinterpret_cast
 *
 */

// https://www.cnblogs.com/lh03061238/p/12936898.html
// The example is wrong. reinterpret_cast is not allowed in constexpr functions
constexpr bool is_little_endian() {
    std::uint16_t x = 0x0001;
    auto p = reinterpret_cast<std::uint8_t*>(&x);
    return *p != 0;
}

TEST(type_casting, endianness) { EXPECT_TRUE(is_little_endian()); }

class A {
  public:
    int i;
};

class B : public A {
    /* B's Memeory
          .----------.
     pc   |    ?     | B
          +----------+
    pc+8  |    i     | A
          +----------+
          |          |
          '----------'
     */
  public:
    virtual void f() {}
};

TEST(type_casting, reinterpret_cast_vs_static_cast) {
    {
        B b;
        b.i = 1;

        A* a = static_cast<A*>(&b);
        std::cout << std::hex << std::setfill('0');
        std::cout << "&b=" << &b << "\n";
        std::cout << "&(b.i)=" << &(b.i) << "\n";
        std::cout << "a=" << a << "\n";

        B* b0 = static_cast<B*>(a);
        std::cout << "b0=" << b0 << "\n";
        std::cout << "&(b0->i)=" << &(b0->i) << "\n";

        std::cout << "value: b.i=" << b.i << "\n";
        std::cout << "value: a->i=" << a->i << "\n";
        std::cout << "value: b0->i=" << b0->i << "\n";
    }

    std::cout << "============\n";

    {
        B b;
        b.i = 1;
        A* a = reinterpret_cast<A*>(&b);
        std::cout << std::hex << std::setfill('0');
        std::cout << "&b=" << &b << "\n";
        std::cout << "&(b.i)=" << &(b.i) << "\n";
        std::cout << "a=" << a << "\n";
        B* b0 = reinterpret_cast<B*>(a);
        std::cout << "b0=" << b0 << "\n";
        std::cout << "&(b0->i)=" << &(b0->i) << "\n";

        std::cout << "value: b.i=" << b.i << "\n";
        std::cout << "value: a->i=" << a->i << "\n";
        std::cout << "value: b0->i=" << b0->i << "\n";
    }

    /*
    &b=0x7ffeadf54bd0
    &(b.i)=0x7ffeadf54bd8
    a=0x7ffeadf54bd8
    b0=0x7ffeadf54bd0
    &(b0->i)=0x7ffeadf54bd8
    value: b.i=1
    value: a->i=1
    value: b0->i=1
    ===============
    &b=0x7ffeadf54bf0
    &(b.i)=0x7ffeadf54bf8
    a=0x7ffeadf54bf0              # 这里，a的地址等于b的. 此时取 i，则是不确定的
    b0=0x7ffeadf54bf0
    &(b0->i)=0x7ffeadf54bf8
    value: b.i=1
    value: a->i=8d6f6040         # undefined a->i
    value: b0->i=1
    */
    // The static_cast correctly returns the address of the embedded A object, and the pointer created by static_cast
    // correctly gives the value of the data field. The pointer generated by reinterpret_cast treats b's memory location
    // as if it were a plain A object, and so when the pointer tries to get the data field it returns some B-specific
    // data as if it were the contents of this field.
    //
    // So reinterpret is always used by replacement new for it won't change the memory size.
    std::cout << std::endl;
}

TEST(type_casting, reinterpret_cast_vs_const_cast) {
    const std::vector<int> vec{0x7FFFFF00, 0x7FFFFF01, 0x7FFFFF02};
    std::string str(vec.begin(), vec.end());  // without compilation error
    EXPECT_EQ(0x00, str[0]);
    EXPECT_EQ(0x01, str[1]);
    EXPECT_EQ(0x02, str[2]);

    std::string str2;
    size_t byte_size = vec.size() * sizeof(int);
    str2.resize(byte_size);
    // void* memcpy( void* dest, const void* src, std::size_t count );

    /*
    when using:
        std::memcpy(reinterpret_cast<void*>(str2.data()), reinterpret_cast<void*>(vec.data()), byte_size);

    Get error: 'reinterpret_cast' from type 'const int*' to type 'void*' casts away qualifiers
    std::memcpy(reinterpret_cast<void*>(str2.data()), reinterpret_cast<void*>(vec.data()), byte_size);
      |                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    */
    // use const_cast to remove the qualifier: const.
    std::memcpy(reinterpret_cast<void*>(str2.data()), reinterpret_cast<void*>(const_cast<int*>(vec.data())), byte_size);

    // Notable: both the vector and string own a memory. The memcpy copys the value from LSB to MSB.
    // That's why the first byte of str2 is the LSB of the first element of the vec.
    EXPECT_THAT(std::vector<char>(str2.begin(), str2.end()),
                testing::ElementsAre(0x00, 0xFF, 0xFF, 0x7F  // 1st integer, 注意他们的顺序
                                     ,
                                     0x01, 0xFF, 0xFF, 0x7F  // 2nd integer
                                     ,
                                     0x02, 0xFF, 0xFF, 0x7F  // 3rd integer
                                     ));
}
